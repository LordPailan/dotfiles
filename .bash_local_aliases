# vi: ft=sh ts=2 sw=2

# functions and aliases, loaded on session start.
# By using meaningful one-line comments to functions, they'll get nicely printed
# by means of the 'my_commands' help function (defined in ~/.bashrc)

# 'Darwin' for Mac, 'Linux' or similar elsewhere
is_mac() {
  [ "$(uname -s)" == "Darwin" ]
}

_get_bash_completion() {
  is_mac && echo "/usr/local/etc/bash_completion"
}

_repo() {
  autocomplete_file="$(_get_bash_completion).d/repo"
  base_dir="$(grep base_dir='.*' "${autocomplete_file}" | cut -d'=' -f2 | tr -d '"' )"
  if [ ! -d "${base_dir}" ] ; then
    read -r -e -p "Base repo dir is not set, or is not a directory. Enter path to repositories base dir: " input
    base_dir="${input/#\~/$HOME}"
    [ ! -d "${base_dir}" ] && \
      echo "Invalid directory: ${base_dir}" && return

    # Update automcomplete file:
    sed -i.bk -e "s#base_dir=.*#base_dir=\"${base_dir}\"#g" "${autocomplete_file}" && \
      rm -rf "${autocomplete_file}.bk"
    echo "Now create a new shell and start using the command" && return
  fi

  orgs_dir="$1"
  repo_name=$2
  fulldir="${base_dir}/${orgs_dir}/${repo_name}"
  if [ ! -d "${fulldir}" ] ; then
    echo "'${fulldir}' is not a directory"
  else
    cd "${fulldir}" || return
  fi
}

_despawn() {
  service=$1
  service_name="spawned_${service//\//_}"
  ids=$(docker ps -a | grep "${service_name}" | awk '{print $1}')
  [ ! -z "$ids" ] && \
    printf "Killing old '%s': %s\n" "$1" "$(docker rm -f "${ids}")"
}

_spawn() {
  # Service name MUST match image name
  service=$1
  service_name="spawned_${service//\//_}"
  shift

  # ports and stuff
  #args=$*

  # first kill old one, if any
  _despawn "${service}" || true

  # And spawn a new service
  printf "Spawning new '%s': %s'\n" "${service}" "$(docker run -d --rm  --name "${service_name}" "$@" "$service")"
}


# Free some Docker disk space
free_docker_space() {
  exited_ps_before=$(docker ps -a -q  -f 'status=exited' | wc -l | tr -d ' ')
  [ "${exited_ps_before}" -gt 0 ] && \
    echo "Deleting ${exited_ps_before}  containers with status 'Exited'..." && \
    docker rm -f "$(docker ps -a -q -f 'status=exited')"

  dangling_images_before=$(docker images -q -a -f "dangling=true" | wc -l | tr -d ' ')
  [ "${dangling_images_before}" -gt 0 ] && \
    echo "Deleting ${dangling_images_before} dangling images..." && \
    docker rmi -f "$(docker images -a -q -f "dangling=true")"
}

# export AWS credentials for given profile
load_aws_credentials() {
  profiles=$(grep -o '\[.*\]' ~/.aws/credentials | tr -d "][")
  [ $# -ne 1 ] && \
    echo "You need to specify one AWS profile among:"  && echo "${profiles}" && \
    return 1

  [ "$1" != "$(echo "${profiles}" | grep "${1}")" ] && \
    echo "Profile '$1' not found. Valid profiles are:" && echo "${profiles}" && \
    return 1

  export AWS_PROFILE=$1
  AWS_ACCESS_KEY_ID=$(aws --profile "${AWS_PROFILE}" configure get aws_access_key_id)
  AWS_SECRET_ACCESS_KEY=$(aws --profile "${AWS_PROFILE}" configure get aws_secret_access_key)

  # export & Dump
  export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
  echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"

  export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
  echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"

  echo "AWS_PROFILE=${AWS_PROFILE}"
}

# Remove given line from file
delete_line() {
  [ $# -ne 2 ] && echo "Usage: delete_line <line_to_delete> <file_name>" && return 1
  line_no=$1
  file=$2
  [ ! -f "${file}" ] && echo "File does not exist" && return 1
  [ ${line_no} -gt $(wc -l $2| awk '{print $1}') ] && echo "Line ${line_no} not found in file ${file}" && return 1

  sed -i -e "${line_no}d" ${file}
}


# Remove duplicated lines from input file into stdout
duprm() {
  if [ "$#" -ne 1 ] ; then
    echo "Missing input file"
    return 1
  fi
  awk '!x[$0]++' "$1"
}

# Allows overriding of GIT commands (try 'git blame ...')
git() {
  case "$@" in
    blame*)
      command echo "Probablemente tu, así que mejor no preguntes" ;;
    * )
      command git "$@"
  esac
}

# Thanks: http://stackoverflow.com/questions/10683349/forcing-bash-to-expand-variables-in-a-string-loaded-from-a-file
# Runs all the shell commands written in the given file
apply_shell_expansion() {
  file="$1"
  [ ! -f "$file" ] && echo "Not a file: $file." && exit 1

  data=$(< "$file")
  delimiter="__apply_shell_expansion_delimiter__"
  command="cat <<$delimiter"$'\n'"$data"$'\n'"$delimiter"
  eval "$command"
}

# Get the N% of the files of the input file
get_rand_lines() {
  in=$1
  N=$2

  if [ -z "$in"  ] || [ ! -f "$in" ] ; then
    echo "[ERROR ] Invalid input file: Syntax is $0 <input_file> [<percentage of lines (Default: 10%)>]"
  else
    [ -z "$N" -o "$N" -lt 0 -o "$N" -gt 100 ] && N=10

    while read -r line ; do
      [ $((RANDOM % 100)) -le $N ] && echo "$line"
    done < "$in"
  fi
}

# Perform a faster, recursive and case-ignoring 'grep' search on a GIT repo.
gg() {
  pattern=$1
  path="."
  if [ $# -gt 1 ] ; then
    shift
    path="$*"
  fi
  git grep -iI "$pattern" "$path" | sed -e 's#^\([^:]*\):\(.*\)$#\1 -> \2#g' | grep -iI "$pattern" --color
}

# Returns true if the current dir is a git repository
is_repo() {
  repo_info="$(git rev-parse --git-dir --is-inside-git-dir \
    --is-bare-repository --is-inside-work-tree \
    --short HEAD 2>/dev/null)"
  [ ! -z "$repo_info" ]
}

# Typical shortcuts
! is_mac && alias ls='ls --color'
alias grep='grep --color'

# Fantastic when you are leaving the company and want to get all your job in one go
alias pull_all='for dir in $(find . -type d) ; do is_repo $dir && (cd $dir && git pull) ; done || true'
alias clean_all='for dir in $(find . -type d) ; do is_repo $dir && (cd $dir && git clean -f) ; done || true'
alias leaving_today='clean_all && pull_all && tar -cjvf /tmp/leaving_new_york_never_easy.bz2 . && mv /tmp/leaving_new_york_never_easy.bz2 . && printf "\n\nDone\nCopy \"leaving_new_york_never_easy.bz2\" somewhere and RUN. FAST\n\n"'

# so sweet
alias cd..='cd ..'

# Get you external IP fast
alias myip='dig +short myip.opendns.com @resolver1.opendns.com'

# Get the owner of each branch, last commit and branch name
alias gitowners='is_repo && for branch in `git branch -r | grep -v HEAD`;do echo -e `git show --format="%an ---> %ai %ar" $branch | head -n 1` \\t$branch; done | sort -r'

# converters for files
alias iso_to_utf='iconv --from-code=iso-8859-1 --to-code=utf-8'
alias utf_to_iso='iconv --to-code=iso-8859-1 --from-code=utf-8'

# with X only, paste output of command into clipboard: echo 'AAA' | ccp
if is_mac ; then alias ccp='pbcopy' ; else alias ccp='xclip -selection clipboard' ; fi

# OSX override of AWK, if installed
is_mac && [ ! -z "$(which gawk)" ] && alias awk='gawk'

# Pushes production, develop, and all tags in one go
alias super.push='git push origin prod  && git push --tags && git push origin develop'

# Stops a Jupyter notebook being run
alias stop.notebook='_despawn jupyter/all-spark-notebook'

# Starts a local Jupyter instance, mounting your current folder as Notebook source
alias spawn.notebook='_spawn jupyter/all-spark-notebook  -v $(pwd):/home/jovyan/work -p 8888:8888'

# stops a redis instance
alias despawn.redis='_despawn redis'

# Starts a local redis instance
alias spawn.redis='_spawn redis -p 6379:6379'

# stops a memcached instance
alias despawn.memcached='_despawn memcached'

# Starts a local memcached instance
alias spawn.memcached='_spawn memcached -p 11211:11211'

# Makes fun of you
alias bim="echo 'LOL eres un mamón, es ''vi'' o ''vim'', no va con B... te lo paso por esta' && read && vim $*"

# Random 32-char string
alias rand.str="cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1"

# Automagically autocomplete repo names and 'cd' into them. Needs a proper base repo dir. Depends on bash_completion. Use an alias to enable _repo to work in current shell
alias repo='_repo'

# DO NOT VERSION THESE THANKS
[ -f ~/.bash_private_aliases ] && source ~/.bash_private_aliases
