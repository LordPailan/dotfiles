#!/bin/bash
# vi: ft=sh ts=2 sw=2

# functions and aliases, loaded on session start.
# By using meaningful one-line comments to functions, they'll get nicely printed
# by means of the 'my_commands' help function (defined in ~/.bashrc)

# Report of disk space usage in current path
sys.disk_usage() {
  for dir in $(ls -h .) ; do
    total=$(du -ch $dir | grep total | egrep -o "[0-9]+[GM]")
    [ ! -z "${total}" ] && echo "Disk usage in $dir: $total"
  done
}

# Find something similar to argument, from here downwards
sys.find() {
  local arg=$1
  shift
  [ ! -z "$*" ] && \
    echo "[WARNING] Ignoring extra input parameters: $*"
  find . -iname "*${arg}*"
}

# Rename a bunch of files
sys.renamer() {
  local where=${1:-.}
  for file in $(find "${where}" -type f -depth 1) ; do
    echo "Type in new name for ${file}? [Empty to ignore]" && read new_name
    [ -z "${new_name}" ] && continue
    mv "${file}" "${new_name}"
  done
}

# Show a pretty error message that actually exits
error() {
  echo "[ERROR] $*"
  exit 1
}

# 'Darwin' for Mac, 'Linux' or similar elsewhere
is_mac() {
  [ "$(uname -s)" == "Darwin" ]
}

_get_bash_completion() {
  is_mac && echo "/usr/local/etc/bash_completion"
}

_virtualenver3() {
  local venv_name venv_dir venv_binaries venv_pip venv_activate venv_global_binary
  venv_name="$(basename "$PWD")_p3.6"
  venv_dir="$(cd "${HOME}/.venvs/" && pwd)/${venv_name}"
  venv_binaries="${venv_dir}/bin"
  venv_pip="${venv_binaries}/pip"
  venv_activate="${venv_binaries}/activate"
  venv_global_binary="virtualenv --python=python3.6"

  # Virtualenv at a global level is a must
  [ -z "$(which virtualenv)" ] && pip install -q virtualenv

  # PIP is a hard requirement, make sure it exists
  [ ! -f "${venv_pip}" ] && ${venv_global_binary} "${venv_dir}"

  # Use pip syntax to install requirements
  local PARAMS=${*:-.}
  "${venv_pip}" install ${PARAMS}

  # I use this with Syntastic :-)
  "${venv_pip}" install pylint

  # Auto activate
  source "${venv_activate}"
}

_virtualenver() {
  local venv_name venv_dir venv_binaries venv_pip venv_activate venv_global_binary
  venv_name=$(basename "$PWD")
  venv_dir="$(cd "${HOME}/.venvs/" && pwd)/${venv_name}"
  venv_binaries="${venv_dir}/bin"
  venv_pip="${venv_binaries}/pip"
  venv_activate="${venv_binaries}/activate"
  venv_global_binary="virtualenv --python=python2.7"

  # Virtualenv at a global level is a must
  [ -z "$(which virtualenv)" ] && pip install -q virtualenv

  # PIP is a hard requirement, make sure it exists
  [ ! -f "${venv_pip}" ] && ${venv_global_binary} "${venv_dir}"

  # Use pip syntax to install requirements
  local PARAMS=${*:-.}
  "${venv_pip}" install ${PARAMS}

  # I use this with Syntastic :-)
  "${venv_pip}" install pylint

  # Auto activate
  source "${venv_activate}"
}

_activate() {
  local venv_name venv_dir venv_activate
  venv_name=$(basename "$PWD")
  venv_dir="$(cd "${HOME}/.venvs/" && pwd)/${venv_name}"
  venv_activate="${venv_dir}/bin/activate"

  [ ! -f "${venv_activate}" ] && echo "No virtualenv called '$venv_name'" && return 1
  source ${venv_activate}
}

_repo() {
  local autocomplete_file="$(_get_bash_completion).d/repo"
  local base_dir="$(grep base_dir='.*' "${autocomplete_file}" | cut -d'=' -f2 | tr -d '"' )"
  if [ ! -d "${base_dir}" ] ; then
    read -r -e -p "Base repo dir is not set, or is not a directory. Enter path to repositories base dir: " input
    base_dir="${input/#\~/$HOME}"
    [ ! -d "${base_dir}" ] && \
      echo "Invalid directory: ${base_dir}" && return

    # Update automcomplete file:
    sed -i.bk -e "s#base_dir=.*#base_dir=\"${base_dir}\"#g" "${autocomplete_file}" && \
      rm -rf "${autocomplete_file}.bk"
    echo "Now create a new shell and start using the command" && return
  fi

  local orgs_dir="$1"
  local repo_name=$2
  local fulldir="${base_dir}/${orgs_dir}/${repo_name}"
  if [ ! -d "${fulldir}" ] ; then
    echo "'${fulldir}' is not a directory"
  else
    cd "${fulldir}" || return
  fi
}

_despawn() {
  local service=$1
  local service_name="spawned_${service//\//_}"
  local ids=$(docker ps -a | grep "${service_name}" | awk '{print $1}')
  [ ! -z "$ids" ] && \
    printf "Killing old '%s': %s\n" "$1" "$(docker rm -f "${ids}")"
}

_spawn() {
  # Service name MUST match image name
  local service=$1
  local service_name="spawned_${service//\//_}"
  shift

  # ports and stuff
  #args=$*

  # first kill old one, if any
  _despawn "${service}" || true

  # And spawn a new service
  printf "Spawning new '%s': %s'\n" "${service}" "$(docker run -d --rm  --name "${service_name}" "$@" "$service")"
}


# Free some Docker disk space
docker.free_space() {
  exited_ps_before=$(docker ps -a -q  -f 'status=exited')
  exited_ps_before_count=$(echo "${exited_ps_before}" | grep -v ^$ | wc -l | tr -d ' ')
  [ ${exited_ps_before_count} -gt 0 ] && \
    echo "Deleting ${exited_ps_before_count}  containers with status 'Exited'..." && \
    docker rm -f $(echo ${exited_ps_before} | xargs)

  dangling_images_before=$(docker images -q -a -f "dangling=true")
  dangling_images_before_count=$(echo "${dangling_images_before}" | grep -v ^$ | wc -l | tr -d ' ')
  [ ${dangling_images_before_count} -gt 0 ] && \
    echo "Deleting ${dangling_images_before_count} dangling images..." && \
    docker rmi -f $(echo ${dangling_images_before} | xargs)

  # Delete volumes
  docker volume rm $(docker volume ls -q)
}

# export AWS credentials for given profile
aws.load_credentials() {
  local profiles=$(grep -o '\[.*\]' ~/.aws/credentials | tr -d "][" | sort -u | xargs )
  local chosen_profile=$1
  if [ -z "${chosen_profile}" ] ; then
    echo "You need to specify one AWS profile in this list:"  && echo "${profiles}"
    echo "Use '-1' to unload session"
    return 1
  fi

  if [ "${chosen_profile}" = "-1" ] ; then
    unset AWS_PROFILE AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
    echo "AWS information unloaded from session"
    return 0
  elif ! grep -q "\[${chosen_profile}\]" ~/.aws/credentials ; then
    echo "Profile '${chosen_profile}' not found. Valid profiles are:" && echo "${profiles}"
    echo "Use '-1' to unload session"
    return 2
  fi

  export AWS_PROFILE=${chosen_profile}
  AWS_ACCESS_KEY_ID=$(aws --profile "${AWS_PROFILE}" configure get aws_access_key_id)
  AWS_SECRET_ACCESS_KEY=$(aws --profile "${AWS_PROFILE}" configure get aws_secret_access_key)

  # export & Dump
  export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
  echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"

  export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
  echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"

  echo "AWS_PROFILE=${AWS_PROFILE}"
}

# Remove given line from file
sys.delete_line() {
  [ $# -ne 2 ] && echo "Usage: delete_line <line_to_delete> <file_name>" && return 1
  line_no=$1
  file=$2
  [ ! -f "${file}" ] && echo "File does not exist" && return 1
  [ ${line_no} -gt $(wc -l $2| awk '{print $1}') ] && echo "Line ${line_no} not found in file ${file}" && return 1

  sed -i -e "${line_no}d" ${file}
}


# Remove duplicated lines from input file into stdout
sys.duprm() {
  if [ "$#" -ne 1 ] ; then
    echo "Missing input file"
    return 1
  fi
  awk '!x[$0]++' "$1"
}

# Allows overriding of GIT commands (try 'git blame ...')
git() {
  case "$@" in
    blame*)
      command echo "Probablemente tu, as√≠ que mejor no preguntes" ;;
    * )
      command git "$@"
  esac
}

# Thanks: http://stackoverflow.com/questions/10683349/forcing-bash-to-expand-variables-in-a-string-loaded-from-a-file
# Runs all the shell commands written in the given file
shell.expansion() {
  file="$1"
  [ ! -f "$file" ] && echo "Not a file: $file." && exit 1

  data=$(< "$file")
  delimiter="__apply_shell_expansion_delimiter__"
  command="cat <<$delimiter"$'\n'"$data"$'\n'"$delimiter"
  eval "$command"
}

# Get the N% of the files of the input file
rand.lines() {
  in=$1
  N=$2

  if [ -z "$in"  ] || [ ! -f "$in" ] ; then
    echo "[ERROR] Invalid input file: Syntax is $0 <input_file> [<percentage of lines (Default: 10%)>]"
  else
    [ -z "$N" -o "$N" -lt 0 -o "$N" -gt 100 ] && N=10

    while read -r line ; do
      [ $((RANDOM % 100)) -le $N ] && echo "$line"
    done < "$in"
  fi
}

# Perform a faster, recursive and case-ignoring 'grep' search on a GIT repo.
gg() {
  pattern=$1
  path="."
  if [ $# -gt 1 ] ; then
    shift
    path="$*"
  fi
  git grep -iI "$pattern" "$path" | sed -e 's#^\([^:]*\):\(.*\)$#\1 -> \2#g' | grep -iI "$pattern" --color
}

# Returns true if the current dir is a git repository
is.repo() {
  repo_info="$(git rev-parse --git-dir --is-inside-git-dir \
    --is-bare-repository --is-inside-work-tree \
    --short HEAD 2>/dev/null)"
  [ ! -z "$repo_info" ]
}

# Typical shortcuts
! is_mac && alias ls='ls --color'
alias grep='grep --color'

# Fantastic when you are leaving the company and want to get all your job in one go
alias git.pull_all='for dir in $(find . -type d) ; do is.repo $dir && (cd $dir && git pull) ; done || true'
alias git.clean_all='for dir in $(find . -type d) ; do is.repo $dir && (cd $dir && git clean -dfx) ; done || true'
alias git.leaving_today='git.clean_all && git.pull_all && tar -cjvf /tmp/leaving_new_york_never_easy.bz2 . && mv /tmp/leaving_new_york_never_easy.bz2 . && printf "\n\nDone\nCopy \"leaving_new_york_never_easy.bz2\" somewhere and RUN. FAST\n\n"'

# so sweet
alias cd..='cd ..'

# Get you external IP fast
alias ip.mine='dig +short myip.opendns.com @resolver1.opendns.com'

# Get the owner of each branch, last commit and branch name
alias git.owners='is.repo && for branch in `git branch -r | grep -v HEAD`;do echo -e `git show --format="%an ---> %ai %ar" $branch | head -n 1` \\t$branch; done | sort -r'

# converters for files
alias sys.iso_to_utf='iconv --from-code=iso-8859-1 --to-code=utf-8'
alias sys.utf_to_iso='iconv --to-code=iso-8859-1 --from-code=utf-8'

# with X only, paste output of command into clipboard: echo 'AAA' | ccp
if is_mac ; then alias ccp='pbcopy' ; else alias ccp='xclip -selection clipboard' ; fi

# OSX override of AWK, if installed
is_mac && [ ! -z "$(which gawk)" ] && alias awk='gawk'

# Pushes production, develop, and all tags in one go
alias super.push='git push origin prod  && git push --tags && git push origin develop'

# Stops a Jupyter notebook being run
alias despawn.ds-notebook='_despawn jupyter/datascience-notebook'

# Starts a local Datascience notebook:  https://github.com/jupyter/docker-stacks/tree/master/datascience-notebook
alias spawn.ds-notebook='_spawn jupyter/datascience-notebook  -v $(pwd):/home/jovyan/work -p 8888:8888'

# Stops a Jupyter notebook being run
alias despawn.notebook='_despawn jupyter/all-spark-notebook'

# Starts a local Jupyter instance, mounting your current folder as Notebook source
alias spawn.notebook='_spawn jupyter/all-spark-notebook  -v $(pwd):/home/jovyan/work -p 8888:8888'

# stops a redis instance
alias despawn.redis='_despawn redis'

# Starts a local redis instance
alias spawn.redis='_spawn redis -p 6379:6379'

# stops a memcached instance
alias despawn.memcached='_despawn memcached'

# Starts a local memcached instance
alias spawn.memcached='_spawn memcached -p 11211:11211'

# Starts a Yack Typewriter off PWD's 'docs' directory
alias spawn.yack='docker run -d --rm --name yack-tw -p 8000:8000  -v $(pwd):/yack/repo -v $(pwd)/_docs_build:/yack/_docs_build containers.schibsted.io/devrel/yack-typewriter make serve'

# Stops a running typewriter
alias despawn.yack='docker kill yack-tw'

# VIM aliases, for great justice
alias bim="echo 'LOL eres un mam√≥n, es ''vi'' o ''vim'', no va con B... te lo paso por esta' && read && vim $*"

# VIM aliases, for even greater justice
alias vin="echo 'VIN?? 'Vin' qu√©, Diesel??? Madre m√≠a, que paciencia...' && read && vim $*"

# Random 32-char string
alias rand.str="cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1"

# Automagically autocomplete repo names and 'cd' into them. Needs a proper base repo dir. Depends on bash_completion.
alias repo='_repo'

# Activate an existing virtualenv in current directory
alias activate='_activate'

# Install and activate a Python 2.7 Virtualenv in current location
alias virtualenver='_virtualenver'

# Install and activate a Python 3.6 Virtualenv in current location
alias virtualenver3='_virtualenver3'

# Copy current path to clipboard - needs 'ccp'
alias ccpath="printf '%s' '$(pwd)' | ccp && echo '$(pwd) copied to Clipboard'"

# test if current path is a GIT repo
alias is_repo='git rev-parse > /dev/null 2>&1'

# DO NOT VERSION THESE THANKS
[ -f ~/.bash_private_aliases ] && source ~/.bash_private_aliases
