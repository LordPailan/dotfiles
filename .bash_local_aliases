# vi: ft=sh ts=2 sw=2

# functions and aliases, loaded on session start.
# By using meaningful one-line comments to functions, they'll get nicely printed
# by means of the 'my_commands' help function (defined in ~/.bashrc)

# export AWS credentials for given profile
load_aws_credentials() {
  profiles=$(grep -o '\[.*\]' ~/.aws/credentials | tr -d "][")
  [ $# -ne 1 ] && \
    echo "You need to specify one AWS profile among:"  && echo "${profiles}" && \
    return 1

  [ "$1" != "$(echo "${profiles}" | grep "${1}")" ] && \
    echo "Profile '$1' not found. Valid profiles are:" && echo "${profiles}" && \
    return 1

  export AWS_PROFILE=$1
  AWS_ACCESS_KEY_ID=$(aws --profile "${AWS_PROFILE}" configure get aws_access_key_id)
  AWS_SECRET_ACCESS_KEY=$(aws --profile "${AWS_PROFILE}" configure get aws_secret_access_key)

  # export & Dump
  export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
  echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"

  export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
  echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"

  echo "AWS_PROFILE=${AWS_PROFILE}"
}

# Remove given line from file
delete_line() {
  [ $# -ne 2 ] && echo "Usage: delete_line <line_to_delete> <file_name>" && return 1
  line_no=$1
  file=$2
  [ ! -f "${file}" ] && echo "File does not exist" && return 1
  [ ${line_no} -gt $(wc -l $2| awk '{print $1}') ] && echo "Line ${line_no} not found in file ${file}" && return 1

  sed -i -e "${line_no}d" ${file}
}


# Remove duplicated lines from input file into stdout
duprm() {
  if [ "$#" -ne 1 ] ; then
    echo "Missing input file"
    return 1
  fi
  awk '!x[$0]++' "$1"
}

# Allows overriding of GIT commands (try 'git blame ...')
git() {
  case "$@" in
    blame*)
      command echo "Probablemente tu, así que mejor no preguntes" ;;
    * )
      command git "$@"
  esac
}

# Thanks: http://stackoverflow.com/questions/10683349/forcing-bash-to-expand-variables-in-a-string-loaded-from-a-file
# Runs all the shell commands written in the given file
apply_shell_expansion() {
  file="$1"
  [ ! -f "$file" ] && echo "Not a file: $file." && exit 1

  data=$(< "$file")
  delimiter="__apply_shell_expansion_delimiter__"
  command="cat <<$delimiter"$'\n'"$data"$'\n'"$delimiter"
  eval "$command"
}

# Get the N% of the files of the input file
get_rand_lines() {
  in=$1
  N=$2

  if [ -z "$in"  ] || [ ! -f "$in" ] ; then
    echo "[ERROR ] Invalid input file: Syntax is $0 <input_file> [<percentage of lines (Default: 10%)>]"
  else
    [ -z "$N" -o "$N" -lt 0 -o "$N" -gt 100 ] && N=10

    while read -r line ; do
      [ $((RANDOM % 100)) -le $N ] && echo "$line"
    done < "$in"
  fi
}

# Perform a faster, recursive and case-ignoring 'grep' search on a GIT repo.
gg() {
  pattern=$1
  path="."
  if [ $# -gt 1 ] ; then
    shift
    path="$*"
  fi
  git grep -iI "$pattern" "$path" | sed -e 's#^\([^:]*\):\(.*\)$#\1 -> \2#g' | grep -iI "$pattern" --color
}

# Returns true if the current dir is a git repository
is_repo() {
  repo_info="$(git rev-parse --git-dir --is-inside-git-dir \
    --is-bare-repository --is-inside-work-tree \
    --short HEAD 2>/dev/null)"
  [ ! -z "$repo_info" ]
}

# Typical shortcuts
! is_mac && alias ls='ls --color'
alias grep='grep --color'

# Fantastic when you are leaving the company and want to get all your job in one go
alias pull_all='for dir in $(find . -type d) ; do is_repo $dir && (cd $dir && git pull) ; done || true'
alias clean_all='for dir in $(find . -type d) ; do is_repo $dir && (cd $dir && git clean -f) ; done || true'
alias leaving_today='clean_all && pull_all && tar -cjvf /tmp/leaving_new_york_never_easy.bz2 . && mv /tmp/leaving_new_york_never_easy.bz2 . && printf "\n\nDone\nCopy \"leaving_new_york_never_easy.bz2\" somewhere and RUN. FAST\n\n"'

# so sweet
alias cd..='cd ..'

# Get you external IP fast
alias myip='dig +short myip.opendns.com @resolver1.opendns.com'

# Get the owner of each branch, last commit and branch name
alias gitowners='is_repo && for branch in `git branch -r | grep -v HEAD`;do echo -e `git show --format="%an ---> %ai %ar" $branch | head -n 1` \\t$branch; done | sort -r'

# converters for files
alias iso_to_utf='iconv --from-code=iso-8859-1 --to-code=utf-8'
alias utf_to_iso='iconv --to-code=iso-8859-1 --from-code=utf-8'

# with X only, paste output of command into clipboard: echo 'AAA' | ccp
if is_mac ; then
  alias ccp='pbcopy'
else
  alias ccp='xclip -selection clipboard'
fi

# OSX override of AWK, if installed
if is_mac && [ ! -z "$(which gawk)" ] ; then
  alias awk='gawk'
fi

# Pushes production, develop, and all tags in one go
alias super.push='git push origin prod  && git push --tags && git push origin develop'

# Spawns a node.js HTTPS server using valid self-signed certificates
alias spawn_server='sudo http-server -p 443 --cors --ssl -a dev.localhost.net --cert ~/ssl/certificates/dev.localhost.net.crt --key ~/ssl/private/dev.localhost.net.key'

# list only directories
alias lsd="ls -l | awk '/^d/ {print $9}'"

# Starts a local Jupyter instance, mounting your current folder as Notebook source
alias start_notebook='docker run -it --rm -v $(pwd):/home/jovyan/work -p 8888:8888 jupyter/all-spark-notebook'

# Spawns a memcached local server
alias start_memcached='docker run -d -p 11211:11211 memcached'

# Makes fun of you
alias bim="echo 'LOL eres un mamón, es ''vi'' o ''vim'', no va con B... te lo paso por esta' && read && vim $*"

# DO NOT VERSION THESE THANKS
[ -f ~/.bash_private_aliases ] && source ~/.bash_private_aliases
